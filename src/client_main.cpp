#include <iostream>
#include <fstream>
#include <chrono>
#include <vector>
#include "client.h"
#include "utils.h"
#include "network.h"
#include "troy.h"
#include "libOTe/Base/SimplestOT.h"
#include "cryptoTools/Common/BitVector.h"
#include "cryptoTools/Crypto/PRNG.h"
#include "cryptoTools/Common/Timer.h"
#include "coproto/Socket/AsioSocket.h"
#include <iostream>
#include <string>
#include <cstdlib>
#include <cstdint>
#include <cstring>
#include <utility>
using namespace std;
using namespace troy;
namespace osuCrypto
{
#ifdef COPROTO_ENABLE_BOOST
    // ==================== OT persistent connection session (client) ====================
    struct SimplestOTClientSession
    {
        PRNG prng;
        SimplestOT otReceiver;
        cp::AsioSocket sock;

        // Records cumulative communication from last read, used to calculate "incremental delta"
        size_t last_bytes_sent = 0;
        size_t last_bytes_recv = 0;

        explicit SimplestOTClientSession(const std::string &ip)
            : prng(sysRandomSeed()), sock(cp::asioConnect(ip, false))
        {
            // Initialize baseline (some implementations may have generated bytes during handshake)
            last_bytes_sent = sock.bytesSent();
            last_bytes_recv = sock.bytesReceived();
        }

        uint64_t recvOne(uint8_t choice_bit, size_t &bytes_sent, size_t &bytes_recv)
        {
            const int totalOTs = 1;
            BitVector choices(totalOTs);
            AlignedVector<block> receivedMsg(totalOTs);
            choices[0] = choice_bit;

            coproto::sync_wait(otReceiver.receiveChosen(
                choices,
                span<block>(receivedMsg.data(), receivedMsg.size()),
                prng,
                sock));

            // flush optional: to reduce latency jitter/syscall counts, consider flushing every N times.
            cp::sync_wait(sock.flush());

            // Note: sock.bytesSent()/bytesReceived() are usually cumulative values since connection establishment.
            // In order to count communication per OT, return the increment of this call.
            const size_t cur_sent = sock.bytesSent();
            const size_t cur_recv = sock.bytesReceived();

            bytes_sent = (cur_sent >= last_bytes_sent) ? (cur_sent - last_bytes_sent) : 0;
            bytes_recv = (cur_recv >= last_bytes_recv) ? (cur_recv - last_bytes_recv) : 0;

            last_bytes_sent = cur_sent;
            last_bytes_recv = cur_recv;

            return receivedMsg[0].get<uint64_t>(0);
        }
    };
#else
    struct SimplestOTClientSession
    {
        explicit SimplestOTClientSession(const std::string &)
        {
            throw std::runtime_error("Error: COPROTO Boost support must be enabled! Please add -DCOPROTO_ENABLE_BOOST=ON when compiling libOTe");
        }
        uint64_t recvOne(uint8_t, size_t &bytes_sent, size_t &bytes_recv)
        {
            bytes_sent = 0;
            bytes_recv = 0;
            return 0;
        }
    };
#endif
}
////////////
struct ClientOptions
{
    string ServerIP;
    int Port;
    string OutputFile;
};

struct QueryResult
{
    uint32_t query;
    uint64_t result;
};

void print_usage()
{
    cout << "Usage:" << endl
         << "\t./PPFE_client <Server IP> <Port> <Output File>" << endl
         << "Description:" << endl
         << "\tServer IP: Server IP address" << endl
         << "\tPort: Server port" << endl
         << "\tOutput File: Output CSV file path" << endl;
}

ClientOptions parse_options(int argc, char *argv[])
{
    ClientOptions options{"", 0, ""};

    try
    {
        if (argc == 4)
        {
            options.ServerIP = argv[1];
            options.Port = stoi(argv[2]);
            options.OutputFile = argv[3];
            return options;
        }
        print_usage();
        exit(0);
    }
    catch (...)
    {
        print_usage();
        exit(0);
    }
}

int main(int argc, char *argv[])
{
    ClientOptions options = parse_options(argc, argv);

    cout << "========== PPFE Client ==========" << endl;
    cout << "Server Address: " << options.ServerIP << ":" << options.Port << endl;
    cout << "Output File: " << options.OutputFile << endl;
    cout << "=================================" << endl;

    // Connect to server
    ClientNetwork network(options.ServerIP, options.Port);
    if (!network.connect())
    {
        cerr << "[Client] Failed to connect to server" << endl;
        return 1;
    }

    int serverSocket = network.getSocket();

    // Receive server configuration
    cout << "[Client] Receiving server configuration..." << endl;
    uint64_t Log2DBSize, EntrySize, plainModulus;

    if (!NetworkHelper::recvData(serverSocket, &Log2DBSize, sizeof(Log2DBSize)) ||
        !NetworkHelper::recvData(serverSocket, &EntrySize, sizeof(EntrySize)) ||
        !NetworkHelper::recvData(serverSocket, &plainModulus, sizeof(plainModulus)))
    {
        cerr << "[Client] Failed to receive server configuration" << endl;
        return 1;
    }

    cout << "[Client] Database Size (Log2): " << Log2DBSize << endl;
    cout << "[Client] Entry Size: " << EntrySize << " bytes" << endl;
    cout << "[Client] Plaintext Modulus: " << plainModulus << endl;

    // Receive server encryption parameters
    cout << "[Client] Receiving server encryption parameters..." << endl;
    uint32_t bgvRingSize, bgvQSize, bgvPlainModuluSize;
    if (!NetworkHelper::recvData(serverSocket, &bgvRingSize, sizeof(bgvRingSize)) ||
        !NetworkHelper::recvData(serverSocket, &bgvQSize, sizeof(bgvQSize)) ||
        !NetworkHelper::recvData(serverSocket, &bgvPlainModuluSize, sizeof(bgvPlainModuluSize)))
    {
        cerr << "[Client] Failed to receive encryption parameters" << endl;
        return 1;
    }

    cout << "[Client] Encryption parameters: RingSize=" << bgvRingSize
         << ", QSize=" << bgvQSize
         << ", PlainModuluSize=" << bgvPlainModuluSize << endl;

    // Create encryption context using parameters sent by server
    EncryptionParameters params(SchemeType::BFV);
    params.set_poly_modulus_degree(bgvRingSize);
    params.set_coeff_modulus(CoeffModulus::create(bgvRingSize, {bgvQSize}));
    params.set_plain_modulus(PlainModulus::batching(bgvRingSize, bgvPlainModuluSize));

    // Get actual coefficient modulus and plaintext modulus
    uint64_t modulus_q = params.coeff_modulus()[0].value();
    uint64_t plain_modulus_value = params.plain_modulus()->value();
    cout << "[Client] Ciphertext modulus q obtained during initialization = " << modulus_q << endl;
    cout << "[Client] Plaintext modulus p obtained during initialization = " << plain_modulus_value << endl;
    cout << "[Client] q % p = " << (modulus_q % plain_modulus_value) << " (0 means p divides q)" << endl;

    HeContextPointer context = HeContext::create(params, true, SecurityLevel::Classical128);

    // Receive server public key
    cout << "[Client] Receiving server public key..." << endl;
    troy::PublicKey public_key;
    if (!NetworkHelper::recvPublicKey(serverSocket, public_key, context))
    {
        cerr << "[Client] Failed to receive public key" << endl;
        return 1;
    }

    BatchEncoder encoder(context);
    Encryptor encryptor(context);
    encryptor.set_public_key(public_key);
    Evaluator evaluator(context);

    // Create key generator
    troy::KeyGenerator keygen(context);

    // Create client object
    OneSVClient client(Log2DBSize, EntrySize, plainModulus);

    // Receive encrypted database
    uint32_t PartNum = 1 << (Log2DBSize / 2);
    uint32_t PartSize = 1 << (Log2DBSize / 2 + Log2DBSize % 2);

    // // Verify if bgvRingSize is large enough
    // uint32_t encoderSlots = encoder.slot_count();
    // if (PartSize >= encoderSlots) {
    //     cerr << "[Client] Error: PartSize (" << PartSize << ") is greater than encoder slot_count (" << encoderSlots << ")" << endl;
    //     cerr << "[Client] Server's bgvRingSize configuration is incorrect, requires at least " << PartSize << endl;
    //     return 1;
    // }
    // cout << "[Client] PartSize=" << PartSize << ", encoder slots=" << encoderSlots << " ✓" << endl;

    cout << "[Client] Receiving encrypted database (" << PartNum << " ciphertexts)..." << endl;
    NetworkHelper::resetPhaseCounters(); // Reset phase counters
    auto offline_comm_start = chrono::high_resolution_clock::now();
    vector<troy::Ciphertext> encryptedDB;
    if (!NetworkHelper::recvCiphertextVector(serverSocket, encryptedDB, PartNum, context))
    {
        cerr << "[Client] Failed to receive encrypted database" << endl;
        return 1;
    }
    auto offline_comm_end = chrono::high_resolution_clock::now();
    auto offline_comm_time = chrono::duration_cast<chrono::milliseconds>(offline_comm_end - offline_comm_start);
    size_t offline_comm_bytes = NetworkHelper::getPhaseBytesRecv();
    cout << "[Client] Encrypted database receiving complete" << endl;
    cout << "[Offline Communication] Time: " << offline_comm_time.count() << " ms, Received: " << (double)offline_comm_bytes / (1024 * 1024) << " MB" << endl;

    // Create a temporary server object (for Offline phase)
    // Note: client code needs modification to accept encrypted database here
    // We need to pass encryptedDB to client

    // For compatibility, create a temporary server object
    // Initialize database for correctness verification
    uint64_t *tempDB = new uint64_t[1 << Log2DBSize];
    initDatabase(&tempDB, Log2DBSize, EntrySize, plainModulus); // Use same initialization function

    OneSVServer tempServer(tempDB, Log2DBSize, EntrySize, context, keygen, plainModulus);
    tempServer.encryptedDB = encryptedDB; // Use encrypted database received from server

    // Run Offline phase (client computation)
    cout << "[Client] Running Offline phase (client computation)..." << endl;
    auto offline_client_compute_start = chrono::high_resolution_clock::now();
    client.Offline(tempServer, encoder, encryptor, evaluator);
    auto offline_client_compute_end = chrono::high_resolution_clock::now();

    // ==================== Offline pre-generation of Enc(0) ====================
    int num_queries_for_precomputation = 1 << (Log2DBSize / 2 + Log2DBSize % 2);
    cout << "[Client] Pre-generating " << num_queries_for_precomputation << " Enc(0) ciphertexts..." << endl;
    auto precompute_start = chrono::high_resolution_clock::now();
    client.precomputeEncZeros(num_queries_for_precomputation, encoder, encryptor);
    auto precompute_end = chrono::high_resolution_clock::now();
    auto precompute_time = chrono::duration_cast<chrono::milliseconds>(precompute_end - precompute_start);
    cout << "[Offline Pre-generation] Time: " << precompute_time.count() << " ms" << endl;

    auto offline_client_compute_time = chrono::duration_cast<chrono::milliseconds>(offline_client_compute_end - offline_client_compute_start);
    cout << "[Offline Client Computation] Time: " << (double)offline_client_compute_time.count() / 1000.0 << " s" << endl;

    // Run Online phase
    uint32_t N = 1 << Log2DBSize;
    uint32_t B = EntrySize / 8;
    uint64_t *result = new uint64_t[B];
    int num_queries = 1 << (Log2DBSize / 2 + Log2DBSize % 2); // queries

    cout << "[Client] Running " << num_queries << " queries..." << endl;

    // Reset communication stats (Offline phase stats)
    size_t offlineBytesRecv = NetworkHelper::getTotalBytesRecv();
    NetworkHelper::resetStats();

    int progress = 0;
    int milestones = num_queries / 5; // queries

    // Performance stats variables
    chrono::microseconds total_online_query_client_time(0);
    chrono::microseconds total_online_query_comm_time(0);
    chrono::microseconds total_online_answer_comm_time(0);
    chrono::microseconds total_online_result_gen_time(0);
    chrono::microseconds total_online_refresh_time(0);

    // Communication stats (real total bytes = main connection + OT connection)
    size_t online_main_bytes_sent = 0;
    size_t online_main_bytes_recv = 0;
    size_t online_ot_bytes_sent = 0;
    size_t online_ot_bytes_recv = 0;

    // Compatible with old output fields: online query sent & online answer received
    // - query sent: main connection sent (queryType + batchQueries etc.) + OT sent (client->server part in OT protocol interaction)
    // - answer received: OT received (server->client message in OT)
    size_t total_online_query_bytes_sent = 0;
    size_t total_online_answer_bytes_recv = 0;

    // Reset communication stats, preparing for online phase stats
    NetworkHelper::resetStats();
    cout << "[Client] Reset communication stats, starting online phase" << endl;

    // Used to store query results for subsequent correctness verification (not included in online time)
    vector<QueryResult> queryResults;

    // ==================== Reuse singleQuery memory to avoid allocation/deep copy in each loop ====================
    std::vector<NetworkHelper::BatchQuery> singleQuery;
    singleQuery.resize(1);
    singleQuery[0].bvec.resize(PartNum);
    singleQuery[0].Svec.resize(PartNum);

    // ==================== OT persistent connection: one connection, multiple OTs ====================
    osuCrypto::SimplestOTClientSession otSession(options.ServerIP + ":8081");

    auto online_start = chrono::high_resolution_clock::now();

    for (uint32_t i = 0; i < num_queries; i++)
    {
        if (milestones > 0 && i % milestones == 0)
        {
            cout << "[Client] Completed: " << progress * 20 << "%" << endl;
            progress++;
        }

        uint16_t part = i % (1 << Log2DBSize / 2);
        uint16_t offset = i % (1 << Log2DBSize / 2);
        uint32_t query = (part << (Log2DBSize / 2)) + offset;

        // 1. Online query client computation
        auto query_client_compute_start = chrono::high_resolution_clock::now();

        uint16_t queryPartNum = query / PartSize;
        uint16_t queryOffset = query & (PartSize - 1);
        bool b_indicator = 0;

        uint64_t hintIndex = client.find_hint(query, queryPartNum, queryOffset, b_indicator);
        if (hintIndex >= client.ciParity.size())
        {
            cerr << "[Client] No valid hint found, skipping query" << endl;
            continue;
        }

        // Construct query parameters
        uint32_t hintID = client.HintID[hintIndex];
        uint32_t cutoff = client.SelectCutoff[hintIndex];
        bool shouldFlip = rand() & 1;

        bool *bvec = client.bvec;
        uint32_t *Svec = client.Svec;

        for (uint32_t part = 0; part < PartNum; part++)
        {
            if (part == queryPartNum)
            {
                bvec[part] = !b_indicator ^ shouldFlip;
                Svec[part] = client.NextDummyIdx() & (PartSize - 1);
                continue;
            }
            else if (client.ExtraPart[hintIndex] == part)
            {
                bvec[part] = b_indicator ^ shouldFlip;
                Svec[part] = client.ExtraOffset[hintIndex];
                continue;
            }

            bool b = client.prf.PRF4Select(hintID, part, cutoff);
            bvec[part] = b ^ shouldFlip;
            if (b == b_indicator)
            {
                Svec[part] = client.prf.PRF4Idx(hintID, part) & (PartSize - 1);
            }
            else
            {
                Svec[part] = client.NextDummyIdx() & (PartSize - 1);
            }
        }

        // Prepare ciphertext
        // uint64_t rando = rand() % plainModulus;
        // vector<uint64_t> ran(PartSize, 0);
        // ran[PartSize - 1] = rando;
        // troy::Plaintext ra = encoder.encode_polynomial_new(ran);
        // Ciphertext ci_copy = client.ciParity[hintIndex];
        // evaluator.add_plain_inplace(ci_copy, ra);
        uint64_t rando = rand() % modulus_q; // Use larger ra for masking, not restricted by plainModulus
        Ciphertext ci_copy = client.ciParity[hintIndex];

        // Use offline pre-generated Enc(0) ciphertext, homomorphically added to ci_copy (avoid overhead of encrypt(0) during online phase)
        const Ciphertext& zero_cipher = client.getNextEncZero();
        evaluator.add_inplace(ci_copy, zero_cipher);
        // Step 1: Increase ra in corresponding components of ciphertext, converting ra from plaintext space to ciphertext space
        // Directly add rando to corresponding position in polynomial c0 of ciphertext (operate on ciphertext modulus q)
        // Note: calculation must be mod q to keep ciphertext valid
        // Use ciphertext modulus q obtained previously
        uint64_t current_coeff = ci_copy.poly(0)[PartSize - 1];
        uint64_t masked_coeff = (current_coeff + rando) % modulus_q; // [MODIFIED, increase large mask] masking with modular arithmetic
        ci_copy.poly(0)[PartSize - 1] = masked_coeff;

        // uint64_t current_coeff1 = ci_copy.poly(0)[PartSize - 1];
        // uint64_t unmasked_coeff = (current_coeff1  - rando) % modulus_q; // unmasking with modular arithmetic
        // ci_copy.poly(0)[PartSize - 1] = unmasked_coeff;

        auto query_client_compute_end = chrono::high_resolution_clock::now();
        total_online_query_client_time += chrono::duration_cast<chrono::microseconds>(query_client_compute_end - query_client_compute_start);

        // 2. Online query communication (send query)
        NetworkHelper::resetPhaseCounters();
        auto query_comm_start = chrono::high_resolution_clock::now();

        // Send query type and single query
        uint8_t queryType = 0x02; // Batch query
        if (!NetworkHelper::sendData(serverSocket, &queryType, sizeof(queryType)))
        {
            cerr << "[Client] Failed to send query type" << endl;
            break;
        }

        // Send single query (batch size 1) - reuse singleQuery memory, avoid allocation and vector::assign each time
        for (uint32_t j = 0; j < PartNum; ++j)
        {
            singleQuery[0].bvec[j] = bvec[j];
            singleQuery[0].Svec[j] = Svec[j];
        }
        // Avoid deep copy if possible: Ciphertext is usually large. Use move to transfer ci_copy resources to singleQuery[0].ciphertext
        // Note: ci_copy unusable after move (won't be used again in this loop), fits semantics
        singleQuery[0].ciphertext = std::move(ci_copy);

        if (!NetworkHelper::sendBatchQueries(serverSocket, singleQuery, PartNum, B, context))
        {
            cerr << "[Client] Failed to send query" << endl;
            break;
        }

        auto query_comm_end = chrono::high_resolution_clock::now();
        total_online_query_comm_time += chrono::duration_cast<chrono::microseconds>(query_comm_end - query_comm_start);

        // Main connection communication: current query stage increment
        const size_t phase_sent = NetworkHelper::getPhaseBytesSent();
        const size_t phase_recv = NetworkHelper::getPhaseBytesRecv();
        online_main_bytes_sent += phase_sent;
        online_main_bytes_recv += phase_recv;

        // Compatible with old fields: query sent first accumulates main connection sent
        total_online_query_bytes_sent += phase_sent;
        //[TO BE MODIFIED]
        uint8_t resultBit = (!b_indicator ^ shouldFlip) ? 0 : 1;
        // 3. Online answer communication (receive response)
        auto answer_comm_start = chrono::high_resolution_clock::now();
        // Record OT stage communication (libOTe/coproto use independent sockets, not counted in NetworkHelper stats)
        size_t ot_bytes_sent = 0;
        size_t ot_bytes_recv = 0;
        uint64_t qq = otSession.recvOne(resultBit, ot_bytes_sent, ot_bytes_recv);

        // OT connection communication: current answer stage increment
        online_ot_bytes_sent += ot_bytes_sent;
        online_ot_bytes_recv += ot_bytes_recv;

        // Compatible with old fields: count client->server bytes in OT interaction as query sent; server->client as answer received
        total_online_query_bytes_sent += ot_bytes_sent;
        total_online_answer_bytes_recv += ot_bytes_recv;

        auto answer_comm_end = chrono::high_resolution_clock::now();
        total_online_answer_comm_time += chrono::duration_cast<chrono::microseconds>(answer_comm_end - answer_comm_start);
        //   total_online_answer_bytes_recv += NetworkHelper::getPhaseBytesRecv();

        // 4. Online generate query result
        auto result_gen_start = chrono::high_resolution_clock::now();

        // Select correct response
        uint64_t temp_result = (qq + modulus_q - (rando % modulus_q)) % modulus_q; // [MODIFIED, unsure if correct] unmasking

        std::vector<uint64_t> temp_phase(1, temp_result); // Input: polynomial of length 1
        std::vector<uint64_t> scaled_result(1);           // Output: scaled result

        // Get context data for current parameter level
        // Note: use first_parms_id() to ensure matching with encryption parameters
        auto context_data = context->get_context_data(context->first_parms_id()).value();

        context_data->rns_tool().decrypt_scale_and_round(
            troy::utils::ConstSlice<uint64_t>(temp_phase.data(), 1, false, nullptr), // Input phase
            1,
            troy::utils::Slice<uint64_t>(scaled_result.data(), 1, false, nullptr) // Output result
        );

        // 3. Extract final decryption result
        // scaled_result[0] is now under plaintext modulus p, can be compared with database value
        uint64_t decrypted_result = scaled_result[0];

        auto result_gen_end = chrono::high_resolution_clock::now();
        total_online_result_gen_time += chrono::duration_cast<chrono::microseconds>(result_gen_end - result_gen_start);

        // 5. Online refresh phase (hint update)
        auto refresh_start = chrono::high_resolution_clock::now();

        // Skip invalid hints
        uint32_t nextIdx = client.getNextHintIndex();
        while (client.SelectCutoff[nextIdx] == 0)
        {
            nextIdx++;
            client.setNextHintIndex(nextIdx);
        }

        // Run Algorithm 5: Replenish a hint using a backup hint
        client.HintID[hintIndex] = nextIdx;
        client.SelectCutoff[hintIndex] = client.SelectCutoff[nextIdx];
        client.ExtraPart[hintIndex] = queryPartNum;
        client.ExtraOffset[hintIndex] = queryOffset;

        // Set the indicator bit to exclude queryPartNum
        bool new_b_indicator = !client.prf.PRF4Select(nextIdx, queryPartNum,
                                                      client.SelectCutoff[nextIdx]);
        client.IndicatorBit[hintIndex / 8] = (client.IndicatorBit[hintIndex / 8] & ~(1 << (hintIndex % 8))) |
                                             (new_b_indicator << (hintIndex % 8));

        uint32_t M = client.getM();
        uint32_t parity_i = nextIdx + ((client.IndicatorBit[hintIndex / 8] >> (hintIndex % 8)) & 1) * M / 2;

        vector<uint64_t> ve(PartSize, 0);
        ve[PartSize - 1] = decrypted_result;
        troy::Plaintext pl = encoder.encode_polynomial_new(ve);

        // Update ciParity
        client.ciParity[hintIndex] = evaluator.add_plain_new(client.ciParity[parity_i], pl);

        client.incrementNextHintIndex();
        nextIdx = client.getNextHintIndex();
        assert(nextIdx < (M + M / 2));

        auto refresh_end = chrono::high_resolution_clock::now();
        total_online_refresh_time += chrono::duration_cast<chrono::microseconds>(refresh_end - refresh_start);

        // Save decryption result for subsequent verification (not included in online time)
        queryResults.push_back({query, decrypted_result});
    }

    auto online_end = chrono::high_resolution_clock::now();
    auto total_online_time = chrono::duration_cast<chrono::milliseconds>(online_end - online_start);
    double online_time = ((double)total_online_time.count()) / num_queries;

    // Get Online phase communication stats
    size_t onlineBytesSent = NetworkHelper::getTotalBytesSent();
    size_t onlineBytesRecv = NetworkHelper::getTotalBytesRecv();

    cout << "[Client] Completed " << num_queries << " queries" << endl;
    cout << "[Client] Total Online Time: " << total_online_time.count() << " ms" << endl;
    cout << "[Client] Average Time Per Query: " << online_time << " ms" << endl;

    // Correctness verification (not included in online time)
    cout << "\n[Client] Starting correctness verification..." << endl;
    bool allCorrect = true;

    for (const auto &result : queryResults)
    {
        if (tempDB[result.query] != result.result)
        {
            allCorrect = false;
            cerr << "[Error] Query " << result.query << " result incorrect: "
                 << "Expected " << tempDB[result.query]
                 << ", Got " << result.result << endl;
        }
    }

    if (allCorrect)
    {
        cout << "[Verification] ✓ All correct!" << endl;
    }
    else
    {
        cout << "[Verification] ✗ Errors exist!" << endl;
    }

    // Detailed Performance Stats
    const size_t online_total_sent = online_main_bytes_sent + online_ot_bytes_sent;
    const size_t online_total_recv = online_main_bytes_recv + online_ot_bytes_recv;
    const size_t online_total_comm = online_total_sent + online_total_recv;

    cout << "\n======================================" << endl;
    cout << "========= Detailed Performance Stats =========" << endl;
    cout << "======================================\n"
         << endl;

    cout << "[Offline Phase]" << endl;
    cout << "  1. Server encryption: see server output" << endl;
    cout << "  2. Offline communication:" << endl;
    cout << "     - Time: " << offline_comm_time.count() << " ms" << endl;
    cout << "     - Received: " << (double)offline_comm_bytes / (1024 * 1024) << " MB" << endl;
    cout << "     - Average communication time per query: " << (double)offline_comm_time.count() / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) << " ms" << endl;
    cout << "     - Average communication volume per query: " << (double)offline_comm_bytes / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) << " bytes" << endl;
    cout << "  3. Offline client computation:" << endl;
    cout << "     - Time: " << offline_client_compute_time.count() / 1000.0 << " s" << endl;
    cout << "     - Average computation time per query: " << (double)offline_client_compute_time.count() / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) / 1000.0 << " s" << endl;
    cout << endl;

    cout << "[Online Phase](" << num_queries << " queries)" << endl;
    cout << "  4. Online query client computation:" << endl;
    cout << "     - Total time: " << total_online_query_client_time.count() / 1000.0 << " ms" << endl;
    cout << "     - Average per query: " << (double)total_online_query_client_time.count() / num_queries / 1000.0 << " ms" << endl;
    cout << "  5. Online query communication (send query):" << endl;
    cout << "     - Total time: " << total_online_query_comm_time.count() / 1000.0 << " ms" << endl;
    cout << "     - Total sent (compatible with old criteria): " << (double)total_online_query_bytes_sent / (1024 * 1024) << " MB" << endl;
    cout << "     - Average time per query: " << (double)total_online_query_comm_time.count() / num_queries / 1000.0 << " ms" << endl;
    cout << "     - Average sent per query (compatible with old criteria): " << (double)total_online_query_bytes_sent / num_queries << " bytes" << endl;
    cout << "  6. Online query server computation: see server output" << endl;
    cout << "  7. Online answer communication (receive response):" << endl;
    cout << "     - Total time: " << total_online_answer_comm_time.count() / 1000.0 << " ms" << endl;
    cout << "     - Total received (compatible with old criteria): " << (double)total_online_answer_bytes_recv / (1024 * 1024) << " MB" << endl;
    cout << "     - Average time per query: " << (double)total_online_answer_comm_time.count() / num_queries / 1000.0 << " ms" << endl;
    cout << "     - Average received per query (compatible with old criteria): " << (double)total_online_answer_bytes_recv / num_queries << " bytes" << endl;
    cout << "  8. Online generate query result:" << endl;
    cout << "     - Total time: " << total_online_result_gen_time.count() / 1000.0 << " ms" << endl;
    cout << "     - Average per query: " << (double)total_online_result_gen_time.count() / num_queries / 1000.0 << " ms" << endl;
    cout << "  9. Online refresh phase (hint update):" << endl;
    cout << "     - Total time: " << total_online_refresh_time.count() / 1000.0 << " ms" << endl;
    cout << "     - Average per query: " << (double)total_online_refresh_time.count() / num_queries / 1000.0 << " ms" << endl;
    cout << endl;

    cout << "[Online Communication Breakdown]" << endl;
    cout << "  - Main connection sent (Query): " << (double)online_main_bytes_sent / (1024 * 1024) << " MB" << endl;
    cout << "  - Main connection received: " << (double)online_main_bytes_recv / (1024 * 1024) << " MB" << endl;
    cout << "  - OT connection sent: " << (double)online_ot_bytes_sent / (1024 * 1024) << " MB" << endl;
    cout << "  - OT connection received (Answer): " << (double)online_ot_bytes_recv / (1024 * 1024) << " MB" << endl;
    cout << endl;

    cout << "[Total]" << endl;
    cout << "  Online total time: " << total_online_time.count() << " ms" << endl;
    cout << "  Online average per query: " << online_time << " ms" << endl;
    cout << "  Total Online communication (real total bytes): " << (double)online_total_comm / (1024 * 1024) << " MB" << endl;
    cout << "    - Total sent: " << (double)online_total_sent / (1024 * 1024) << " MB" << endl;
    cout << "    - Total received: " << (double)online_total_recv / (1024 * 1024) << " MB" << endl;
    cout << "  Average communication per query (real total bytes): " << (double)online_total_comm / num_queries << " bytes" << endl;
    cout << "  Average time per query (including amortized Offline): " << online_time + (double)offline_comm_time.count() / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) << " ms" << endl;
    cout << "  Average communication per query (including amortized Offline): " << (double)online_total_comm / num_queries + (double)offline_comm_bytes / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) << " bytes" << endl;
    cout << "======================================\n"
         << endl;

    // Write to output file
    ofstream output_csv;
    if (access(options.OutputFile.c_str(), F_OK) == -1)
    {
        output_csv.open(options.OutputFile);
        output_csv << "Variant, Log2 DBSize, EntrySize(Bytes), NumQueries, Offline Time (s), Online Time (ms), Amortized Compute Time Per Query (ms)" << endl;
    }
    else
    {
        output_csv.open(options.OutputFile, ofstream::out | ofstream::app);
    }

    // Calculate total offline time (communication time + client computation time)
    auto total_offline_time = offline_comm_time + offline_client_compute_time;

    double amortized_compute_time_per_query = ((double)total_offline_time.count()) / (0.5 * LAMBDA * (1 << (Log2DBSize / 2))) + online_time;

    output_csv << "One server, " << Log2DBSize << ", " << EntrySize << ", "
               << num_queries << ", " << (double)total_offline_time.count() / 1000.0 << ", "
               << online_time << ", " << amortized_compute_time_per_query << endl;

    output_csv.close();

    // Send end signal
    uint8_t endSignal = 0xFF;
    NetworkHelper::sendData(serverSocket, &endSignal, sizeof(endSignal));

    // Cleanup
    delete[] result;
    delete[] tempDB;

    network.disconnect();

    cout << "[Client] Done" << endl;

    return 0;
}

